---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
n <- 1500
X <- seq(0,1, length = n)
 
f0 <- X + pmax(X-0.1,0) + pmax(X- 0.3,0) +  3*pmax(X- 0.6,0) +  2*pmax(X- 0.85,0)
Y <- rnorm(n, mean = f0, sd = 0.25)
plot(X,Y)
Xcopy <- X
Hn_func <- function(t){
  mean(pmax(t-Xcopy,0)*Y)
}
n <- 500
X <- seq(0,1, length = n)
h <- X[2] - X[1]
f0 <-X + pmax(X-0.1,0) + pmax(X- 0.3,0) +  3*pmax(X- 0.6,0) +  2*pmax(X- 0.85,0)


Hn_func <- Vectorize(Hn_func)
Hn <- Hn_func(X)

 
plot(X,Hn)


loop <- c(1,-4,6,-4,1)
 
k <- length(loop)
subset_col <- t((matrix(1:k, nrow = n-k+1, ncol = k, byrow=T) + 0:(n-k)))
subset_row <- t(matrix(1:(n-k+1), nrow = n-k+1, ncol = k, byrow=F)) 
index <- cbind(as.vector(subset_row), as.vector(subset_col))
Delta <- matrix(0, ncol = n, nrow = n-k+1)
Delta[index] <- loop
b <- rep(0, nrow(Delta))
diag <- -1*diag(1, nrow = n, ncol = n) 
A <- rbind(Delta, diag)
b <- c(b, -Hn)
D <- diag(1, nrow = n, ncol = n)
d <- Hn
library(quadprog)
out <- solve.QP(D, d, t(A), b)
plot(X,out$solution, type = "l")

```


```{r}
quantile(Delta %*% out$solution)
quantile(out$solution - Hn)

X[which(Delta %*% out$solution > 1e-10)]

```

```{r}
quantile(Delta %*% out$solution)
loop <- c(1,-2,1)/h^2
 k <- length(loop)
subset_col <- t((matrix(1:k, nrow = n-k+1, ncol = k, byrow=T) + 0:(n-k)))
subset_row <- t(matrix(1:(n-k+1), nrow = n-k+1, ncol = k, byrow=F)) 
index <- cbind(as.vector(subset_row), as.vector(subset_col))
Delta_mono <- matrix(0, ncol = n, nrow = n-k+1)
Delta_mono[index] <- loop
fn <- Delta_mono %*% out$solution
plot(X[-c(1, length(X))],  fn, type = "l")
plot(X,  f0, type = "l")
mean((f0[-c(1,length(f0))]- fn)^2)
```




```{r}
library(rmarkdown)
library(knitr); opts_knit$set(root.dir="~/correlates_reporting_forks/correlates_reporting-1"); render("~/correlates_reporting_forks/correlates_reporting-1/cor_threshold/report_test.Rmd", output_dir = getwd(),   knit_root_dir ="~/correlates_reporting_forks/correlates_reporting-1" )
 
```



```{r}

p <- dnorm(X)
basis_list <- enumerate_basis(as.matrix(X), smoothness_orders=1)
basis_list <- c(basis_list, list(list(cols = 1, cutoffs = -5, orders = 0)))
fit <- fit_hal(X,Y,   smoothness_orders = 1, fit_control = list(cv_select = F, lower.limits = c(-Inf, rep(0, length(basis_list)-1)) ), lambda = 1e-9, basis_list = basis_list)
fit <- squash_hal_fit(fit)
knots <- sapply(fit$basis_list, `[[`, "cutoffs")
Q <- predict(fit, new_data = X)
Y-Q
plot(X,Q)
plot(X,Y)
plot(X,X^2)
```

```{r}
knots
Hn <- function(t) {
  mean(Y*pmax(X-t,0))
}
Fn <- function(t) {
  mean(Y*(t >= X))
}

Ht <- function(t) {
  mean(Q*pmax(X-t,0))
}
Ft <- function(t) {
  mean(Q*(t >= X))
}
Hn <- Vectorize(Hn)
Fn <- Vectorize(Fn)
Ht <- Vectorize(Ht)
Ft <- Vectorize(Ft)
grid <- sort(unique(X))
plot(grid, Hn(grid), col = "red", type = "l")
lines(grid, Ht(grid), col = "blue")
quantile(Ht(grid) - Hn(grid), seq(0,1,length=10))


plot(grid[-1], diff(Fn(grid))/diff(grid), col = "red", type = "l")
lines(grid[-1], diff(Ft(grid)) / diff(grid), col = "blue")
quantile(Ft(knots) - Fn(knots), seq(0,1,length=10))

```


```{r}
library(pracma)

cubicspline(x, y, xi = NULL, endp2nd = FALSE, der = c(0, 0))

```

```{r}
plot(X,Y)
h <- 0.01
grid <- seq(0,1,h)
Hn <- function(t) {
  mean(Y*pmax(t-X,0))
}
Fn <- function(t) {
  mean(Y*(t >= X))
}
Hn <- Vectorize(Hn)
Fn <- Vectorize(Fn)
plot(grid, Fn(grid))
plot(grid, Hn(grid))

deriv <- diff(Fn(grid))
deriv <- c(deriv[1], deriv)/h
plot(grid, deriv)


Hn_vals <- Hn(grid)
Delta_op <- function(vals, k, i) {
  if(i > length(vals) - k) {
    stop("i too large")
  }
  if(k ==0){
    return(vals[i])
  } else {
    val <- Delta_op(vals, k-1, i+1) - Delta_op(vals, k-1, i)
    val <- round(val, digits = 12)
    return(val)
  }
}
Delta_op <- Vectorize(Delta_op, vectorize.args = "i")
```


```{r}
cubic_spline <- function(x, x0, x1, y0, y1, m0, m1, k = 0) {
  t <- (x - x0)/(x1 - x0)
  Delta <- (x1 - x0)
  
  if(k==0) {
     z <- (2*t^3 - 3*t^2 + 1)*y0 + 
     (t^3 - 2*t^2 + t)*m0*Delta +
     (-2*t^3 + 3*t^2)*y1 +
     (t^3 - t^2)*m1*Delta
    return(z)
  }
  
   
  if(k==1) {
    z1 <- (6*t^2 - 6*t )*y0 + 
     (3*t^2 - 4*t + 1)*m0*Delta +
     (-6*t^2 + 6*t)*y1 +
     (3*t^2 - 2*t)*m1*Delta
    return(z1)
  }
   
  if(k==2) {
    z2 <- (12*t - 6 )*y0 + 
     (6*t - 4)*m0*Delta +
     (-12*t + 6)*y1 +
     (6*t - 2)*m1*Delta
    return(z2)
  }
}

eval_cubic <- function(x, active, knots, Hn, Fn, k=0,method = "fmm") {

  
  fun <- (splinefun(knots[active], Hn[active], method = method))
   return(fun(x, deriv = k))
  
  index <- findInterval(x, knots[active], all.inside = TRUE)
 
  index1 <- active[index]
  index2 <- active[index + 1]
  x0 <- knots[index1]
  x1 <- knots[index2]
  y0 <- Hn[index1]
  y1 <- Hn[index2]
  m0 <- Fn[index1]
  m1 <- Fn[index2]
  
  return(cubic_spline(x, x0, x1, y0, y1, m0, m1, k))
}
```

```{r}
grid <- sort(unique(X))
Hn_grid <- Hn(grid)
Fn_grid <- Fn(grid)

knots <- sort(unique(X))
Hn_knots <- Hn(knots)
Fn_knots <- Fn(knots)
#Delta_op(Hn_vals, 4, 1:(length(Hn_vals)-4))
active <- c(50)

 
Ht <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots )
ft <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots , k =2)

for(i in 1:4) {
 
  print(i)
    print(quantile(Ht - Hn_knots))
  print(active)
  t <- (1:length(knots))[-active][which.min(Ht[-active] - Hn_knots[-active])]
  old_active <- active
  active <- sort(union(active, t))
  Ht <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots )
   tmp_knots  <- knots[sort(union(c(1, length(knots)),active))]

  ftnew <- eval_cubic(tmp_knots, active , knots, Hn_knots, Fn_knots, k=2 )
   ft <- eval_cubic(tmp_knots, old_active , knots, Hn_knots, Fn_knots, k=2 )
   print(ft)
   print(ftnew)
  is_convex <- all(diff(diff(ftnew)/diff(tmp_knots)) >=-1e-9)
  print(paste0("convex: ", is_convex))
    print(diff(ft)/diff(tmp_knots))
     print(diff(ftnew-ft)/diff(tmp_knots))
  if(!is_convex) {
    
    lambdas <- seq(0.00001, .9999, length = 1000)
    for(lambda in lambdas) {
      new <- ft + lambda*(ftnew - ft)
  
      is_convex <- all(diff(diff(new)/diff(tmp_knots)) >=-1e-9)
      if(is_convex) {
        print("here")
        print(lambda)
        break
      }
    }
     keep <- (which(abs(diff(diff(new)/diff(tmp_knots))) > 1e-12 ))
  print(active)
  print(keep)
  print(((diff(new)/diff(tmp_knots)))[active-1])
  active <- keep + 1
  ft <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots , k =2)
  } else {
    ft <- ftnew
  }
 
  
  
}
t <- (1:length(knots))[-active][which.min(Ht[-active] - Hn_knots[-active])]

plot(knots, Ht)
plot(knots, Hn_knots)
plot(knots, ft)
deriv <- diff(ft)/diff(knots)



```

ft <- eval_cubic(knots , active , knots, Hn_knots, Fn_knots, k=3 )
for(i in 1:7) {
  print(i)
  t <- (1:length(knots))[-active][which.min(Ht[-active] - Hn_knots[-active])]
  old_active <- active
  active <- sort(union(active, t))
  Ht <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots )
  ftnew <- eval_cubic(knots, active , knots, Hn_knots, Fn_knots, k=3 )
 ft <- eval_cubic(knots , old_active , knots, Hn_knots, Fn_knots, k=3 )
  
 print(diff(ftnew[active]))
  if(!all(diff(ftnew)[-c(1,length(ftnew)-1)] >= 0)) {
  lambdas <- seq(0.00001, .9909, length = 1000)
  for(lambda in lambdas) {
    new <- ft + lambda*(ftnew - ft)
    if(all(diff(new)[-c(1,length(ftnew)-1)] >= 0)) {
      print("here")
      break
    }
  }
  print(diff(new))
  active <- c(active[1], active[-c(1,length(active)-1)][-which.min(diff(new[active])[-c(1,length(active)-1)])], active[length(active)-1])
  Ht <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots )
   ft <- eval_cubic(knots , active , knots, Hn_knots, Fn_knots, k=3 )
   print(diff(ft[active]))
  }
   
  
}
```

```{r}
Htnew <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots, k=0 )
ftnew <- eval_cubic(grid, active , knots, Hn_knots, Fn_knots, k=3 )
plot(grid,Htnew)
plot(grid,ftnew)
 
```

```{r}

ys

plot(X,cubic_spline(X, knots[active][1], knots[active][2], ys[1], ys[2], ms[1], ms[2]))
             
```


